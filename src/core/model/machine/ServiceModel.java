/*
 * This code is part of the ThornSec project.
 *
 * To learn more, please head to its GitHub repo: @privacyint
 *
 * Pull requests encouraged.
 */
package core.model.machine;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Optional;
import core.data.machine.ServiceData;
import core.data.machine.ServerData.GuestOS;
import core.data.machine.AMachineData.MachineType;
import core.data.machine.ServerData;
import core.data.machine.configuration.DiskData.Format;
import core.data.machine.configuration.DiskData.Medium;
import core.data.machine.configuration.NetworkInterfaceData;
import core.exception.AThornSecException;
import core.exception.data.machine.InvalidDiskSizeException;
import core.exception.runtime.InvalidMachineModelException;
import core.iface.IUnit;
import core.model.machine.configuration.DiskModel;
import core.model.machine.configuration.networking.DHCPClientInterfaceModel;
import core.model.network.NetworkModel;

/**
 * This model represents a Service on our network.
 *
 * A service is a machine which is run on a HyperVisor
 */
public class ServiceModel extends ServerModel {

	private Map<String, DiskModel> disks;
	private HypervisorModel hypervisor;

	private static Integer DEFAULT_BOOT_DISK_SIZE = (8 * 1024); //8GB
	private static Integer DEFAULT_DATA_DISK_SIZE = (20 * 1024); //20GB

	public ServiceModel(ServerData myData, NetworkModel networkModel)
			throws AThornSecException {
		super(myData, networkModel);

		this.addType(MachineType.SERVICE);

		if (null == this.getNetworkInterfaces()) {
			final DHCPClientInterfaceModel nic = new DHCPClientInterfaceModel(new NetworkInterfaceData("eth0"), networkModel);
			this.addNetworkInterface(nic);
		}
	}

	@Override
	public GuestOS getOS() {
		return getData().getOS()
						.orElse(GuestOS.ALPINE_64);
	}

	@Override
	public void init() throws AThornSecException {
		super.init();

		String hypervisorLabel = getData().getHypervisor().getLabel();
		HypervisorModel hv = (HypervisorModel) getNetworkModel().getMachineModel(hypervisorLabel); 
		setHypervisor(hv);

		getData().getDisks().ifPresent((disks) -> {
			disks.forEach((label, diskData) -> {
				try {
					addDisk(new DiskModel(diskData, getNetworkModel()));
				} catch (final InvalidDiskSizeException e) {
					// Famous last words go here...
				}
			});
		});

		if (getDisk("boot").isEmpty()) {
			File bootDiskPath = new File(hypervisor.getVMBase().getAbsolutePath() + "/disks/boot/" + getLabel() + "/boot.vmdk");
			DiskModel bootDisk = new DiskModel("boot", Medium.DISK, Format.VMDK, bootDiskPath, DEFAULT_BOOT_DISK_SIZE, null, "autogenerated boot disk", getNetworkModel());
			addDisk(bootDisk);
		}
		if (getDisk("data").isEmpty()) {
			File dataDiskPath = new File(this.hypervisor.getVMBase().getAbsolutePath() + "/disks/data/" + getLabel() + "/data.vmdk");
			DiskModel dataDisk = new DiskModel("data", Medium.DISK, Format.VMDK, dataDiskPath, DEFAULT_DATA_DISK_SIZE, null, "autogenerated data disk", getNetworkModel());
			addDisk(dataDisk);
		}
		if (getDisk("install").isEmpty()) {
			File dataDiskPath = new File(this.hypervisor.getVMBase().getAbsolutePath() + "/isos/" + getLabel() + "/" + getLabel() + ".iso");
			DiskModel dataDisk = new DiskModel("debian", Medium.DVD, null, dataDiskPath, 666, null, "autogenerated iso disk", getNetworkModel());
			addDisk(dataDisk);
		}
	}

	public String getHypervisorLabel() {
		return this.hypervisor.getLabel();
	}

	public HypervisorModel getHypervisorModel() throws InvalidMachineModelException {
		return (HypervisorModel) getNetworkModel().getMachineModel(getData().getLabel());
	}

	public void setHypervisor(HypervisorModel hypervisorModel) {
		this.hypervisor = hypervisorModel;
	}

	public void addDisk(DiskModel disk) {
		if (this.disks == null) {
			this.disks = new LinkedHashMap<>();
		}

		this.disks.put(disk.getLabel(), disk);
	}

	public Map<String, DiskModel> getDisks() {
		return this.disks;
	}

	public Optional<DiskModel> getDisk(String label) {
		if (getDisks() == null || !getDisks().containsKey(label)) {
			return Optional.empty();
		}
		return Optional.of(getDisks().get(label));
	}

	@Override
	public ServiceData getData() {
		return (ServiceData) super.getData();
	}

	/**
	 * Get the amount of RAM allocated to this machine
	 * @return optionally the amount of RAM in MB, or 2048 if not set
	 */
	public Integer getRAM() {
		return getData().getRAM()
						.orElse(2048);
	}

	/**
	 * Get the CPU execution cap for this machine
	 * @return optionally the execution cap in %, or 100 if not set
	 */
	public Integer getCPUExecutionCap() {
		return getData().getCPUExecutionCap()
						.orElse(100);
	}

	public Collection<? extends IUnit> getUserPasswordUnits() {
		// TODO Auto-generated method stub
		return new ArrayList<>();
	}
}
