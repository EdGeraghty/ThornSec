/*
 * This code is part of the ThornSec project.
 *
 * To learn more, please head to its GitHub repo: @privacyint
 *
 * Pull requests encouraged.
 */
package core.model.machine;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Optional;
import core.data.machine.ServiceData;
import core.data.machine.AMachineData.MachineType;
import core.data.machine.ServiceData.GuestOS;
import core.data.machine.configuration.DiskData.Format;
import core.data.machine.configuration.DiskData.Medium;
import core.data.machine.configuration.NetworkInterfaceData;
import core.exception.AThornSecException;
import core.exception.data.machine.InvalidDiskSizeException;
import core.exception.runtime.InvalidGuestOSException;
import core.exception.runtime.InvalidMachineModelException;
import core.iface.IUnit;
import core.model.machine.configuration.DiskModel;
import core.model.machine.configuration.networking.StaticInterfaceModel;
import core.model.network.NetworkModel;
import profile.guest.AGuestProfile;
import profile.guest.AlpineVM;
import profile.guest.DebianVM;

/**
 * This model represents a Service on our network.
 *
 * A service is a machine which is run on a HyperVisor
 */
public class ServiceModel extends ServerModel {
	
	private Map<String, DiskModel> disks;
	private HypervisorModel hypervisor;
	
	private AGuestProfile guestOS;
	
	private String iso;
	private String isoSHA512;
	
	private static Integer DEFAULT_BOOT_DISK_SIZE = (8 * 1024); //8GB
	private static Integer DEFAULT_DATA_DISK_SIZE = (20 * 1024); //20GB
	
	public ServiceModel(ServiceData myData, NetworkModel networkModel)
			throws AThornSecException {
		super(myData, networkModel);
		
		this.addType(MachineType.SERVICE);
		
		this.setGuestOS(getOS());
		this.iso = getData().getIsoUrl();
		this.isoSHA512 = getData().getIsoSha512();
		
		if (this.getNetworkInterfaces() == null) {
			StaticInterfaceModel nic = new StaticInterfaceModel(new NetworkInterfaceData("eth0"), networkModel);
			this.addNetworkInterface(nic);
		}
	}

	private void setGuestOS(GuestOS os) throws AThornSecException {
		if (GuestOS.debian.contains(os)) {
			this.guestOS = new AlpineVM(this);
		}
		else if (GuestOS.alpine.contains(os)) {
			this.guestOS = new DebianVM(this);
		}
		else {
			throw new InvalidGuestOSException(os.toString());
		}
	}

	@Override
	public void init() throws InvalidDiskSizeException, InvalidMachineModelException {

		String hypervisorLabel = getData().getHypervisor().getLabel();
		HypervisorModel hv = (HypervisorModel) getNetworkModel().getMachineModel(hypervisorLabel); 
		setHypervisor(hv);

		getData().getDisks().ifPresent((disks) -> {
			disks.forEach((label, diskData) -> {
				addDisk(new DiskModel(diskData, getNetworkModel()));
			});
		});

		if (getDisk("boot").isEmpty()) {
			File bootDiskPath = new File(hypervisor.getVMBase().getAbsolutePath() + "/disks/boot/" + getLabel() + "/boot.vmdk");
			DiskModel bootDisk = new DiskModel("boot", Medium.DISK, Format.VMDK, bootDiskPath, DEFAULT_BOOT_DISK_SIZE, null, "autogenerated boot disk", getNetworkModel());
			addDisk(bootDisk);
		}
		if (getDisk("data").isEmpty()) {
			File dataDiskPath = new File(this.hypervisor.getVMBase().getAbsolutePath() + "/disks/data/" + getLabel() + "/data.vmdk");
			DiskModel dataDisk = new DiskModel("data", Medium.DISK, Format.VMDK, dataDiskPath, DEFAULT_DATA_DISK_SIZE, null, "autogenerated data disk", getNetworkModel());
			addDisk(dataDisk);
		}
		if (getDisk("install").isEmpty()) {
			File dataDiskPath = new File(this.hypervisor.getVMBase().getAbsolutePath() + "/isos/" + getLabel() + "/" + getLabel() + ".iso");
			DiskModel dataDisk = new DiskModel("debian", Medium.DVD, null, dataDiskPath, 666, null, "autogenerated iso disk", getNetworkModel());
			addDisk(dataDisk);
		}

	}

	public String getHypervisorLabel() {
		return this.hypervisor.getLabel();
	}

	public HypervisorModel getHypervisorModel() throws InvalidMachineModelException {
		return (HypervisorModel) getNetworkModel().getMachineModel(getData().getLabel());
	}

	public void setHypervisor(HypervisorModel hypervisorModel) {
		this.hypervisor = hypervisorModel;
	}

	public void addDisk(DiskModel disk) {
		if (this.disks == null) {
			this.disks = new LinkedHashMap<>();
		}

		this.disks.put(disk.getLabel(), disk);
	}

	public Map<String, DiskModel> getDisks() {
		return this.disks;
	}

	public Optional<DiskModel> getDisk(String label) {
		if (getDisks() == null || !getDisks().containsKey(label)) {
			return Optional.empty();
		}
		return Optional.of(getDisks().get(label));
	}
	
	@Override
	public ServiceData getData() {
		return (ServiceData) super.getData();
	}

	/**
	 * Get the amount of RAM allocated to this machine
	 * @return optionally the amount of RAM in MB, or 2048 if not set
	 */
	public Integer getRAM() {
		return getData().getRAM()
						.orElse(2048);
	}

	/**
	 * Get the CPU execution cap for this machine
	 * @return optionally the execution cap in %, or 100 if not set
	 */
	public Integer getCPUExecutionCap() {
		return getData().getCPUExecutionCap()
						.orElse(100);
	}

	public Optional<String> getIsoUrl() {
		return Optional.ofNullable(this.iso);
	}

	public void setIsoURL(String url) {
		this.iso = url;
	}
	
	public void setIsoSHA512(String checksum) {
		this.isoSHA512 = checksum;
	}

	public Optional<String> getIsoSHA512() {
		return Optional.ofNullable(this.isoSHA512);
	}
	
	public GuestOS getOS() {
		return getData().getOS()
						.orElse(GuestOS.ALPINE_64);
	}

	public Collection<? extends IUnit> getISODownloadUnits() {
		// TODO Auto-generated method stub
		return new ArrayList<>();
	}

	public Collection<? extends IUnit> getUserPasswordUnits() {
		// TODO Auto-generated method stub
		return new ArrayList<>();
	}
}
